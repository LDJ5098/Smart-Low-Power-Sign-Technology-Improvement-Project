1단계: 수동 배포에서 자동화의 길로 (Automation)
보안 개념: 사람이 직접 접속할 때 발생하는 '휴먼 에러'와 '자격 증명 노출' 방지.

코드 구현: GitLab CI/CD 파이프라인(.gitlab-ci.yml)을 생성하고, 서버에 접속하는 기본 명령어 작성.

실험 기록: "내가 직접 치던 명령어를 봇(GitLab)이 똑같이 수행하는 것을 확인했다."

2단계: 성문을 지키는 장갑차 (SSH Key Auth)
보안 개념: 훔치기 쉬운 비밀번호 대신, 수학적으로 복제가 불가능한 SSH Key 도입.

코드 구현: ssh-keygen으로 열쇠를 만들고, 서버의 authorized_keys에 자물쇠 등록.

실험 기록: "비밀번호 입력 없이 오직 내 열쇠로만 서버에 안전하게 접속하는 '장갑차'를 완성했다."

3단계: 권한의 분리, 마스터와 일꾼 (Separation of Duties)
보안 개념: 나(관리자)와 봇(실행자)의 열쇠를 분리하여 사고 발생 시 피해를 격리함.

코드 구현: 동주 님용과 봇용 SSH Key를 각각 생성하고 개별 관리.

실험 기록: "동주 님 열쇠는 비번(Passphrase)을 걸어 강화하고, 봇 열쇠는 자동화를 위해 비번 없이 만들어 용도에 맞게 분리했다."

4단계: 흔적 없는 요새 (Stateless & Zero-Trace)
보안 개념: 존재하지 않는 데이터는 해킹당할 수 없다. 로컬의 봇 열쇠를 파기함.

코드 구현: 봇의 개인키를 GitLab Secret Variables에 봉인한 후, 내 PC의 원본 파일을 삭제(rm / del).

실험 기록: "봇의 열쇠를 금고에 넣고 내 PC에서 소멸시켰다. 이제 나조차도 봇의 이름으로 서버에 들어갈 수 없는 '완벽한 격리'를 실현했다."

5단계: 무인 성의 자동 응징 (GitOps & Self-Healing)
보안 개념: 서버 상태를 실시간 감시하고 비정상 변경(Drift) 시 자동으로 복구 및 차단.

코드 구현: 서버 상태와 깃랩 코드를 비교하는 로직 구상 및 비인가 IP 차단 시나리오 수립.

실험 기록: "서버가 스스로를 치유하고 침입자를 쫓아내는 '자율 방어' 체계를 설계했다. 이제 이 성에는 사람이 살지 않아도 안전하다."